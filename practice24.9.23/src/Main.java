public class Main {
    public static void main(String[] args) {
        //子类与父类
        //继承
        //java中只支持单继承,一个类只能有一个父类,但是可以有多个子类
        //格式：class 子类名 extends 父类名{}
        //Object类是所有类的父类,如果一个类没有继承任何类,默认继承Object类
        //子类可以继承父类的属性和方法,但是不能继承父类的构造方法
        /*
           1. 如果子类和父类在一个包下,子类可以继承父类的所有属性和方法,不管父类的属性和方法的修饰符是什么
           2. 如果子类和父类不在一个包下,子类只能继承父类的public和protected修饰的属性和方法
           3. 子类不能继承父类的private修饰的属性和方法
           4. 类的访问权限有：private、默认、protected、public
                1. private：只能在本类中访问
                2. 默认：只能在本类和同一个包下的类中访问
                3. protected：只能在本类、同一个包下的类、不同包下的子类中访问
                4. public：只要导入包，就可以访问
         */
        //子类对象的生成：子列创建对象时，会先调用父类的构造方法，再调用子类的构造方法，如果子类没有构造方法，会默认调用父类的无参构造方法

        //成员变量的隐藏和方法的重写
        //成员变量的隐藏：子类和父类有相同的成员变量时，子类会隐藏父类的成员变量，子类对象访问成员变量时，访问的是子类的成员变量(如果要访问，用super关键字)
        //方法的重写：子类和父类有相同的方法时，子类会重写父类的方法，子类对象调用方法时，调用的是子类的方法(如果要调用父类的方法，用super关键字)
        /*
        方法重写的规则：
        1. 子类的重写方法的访问修饰符不能小于父类的被重写方法的访问修饰符（public>protected>默认(有好的)>private）
        2. 子类的重写方法的返回值类型和父类的被重写方法的返回值类型相同或者是父类返回值类型的子类
        3. 子类的重写方法的方法名和父类的被重写方法的方法名相同
        4. 子类的重写方法的形参列表和父类的被重写方法的形参列表相同
        方法重写的格式：
        修饰符 返回值类型 方法名(参数列表){
            //方法体
        }
         */


        //super关键字
        //super关键字是一个引用变量，它是子类对象的引用
        //super关键字可以用来访问父类的属性和方法（格式：super.属性名、super.方法名()）
        //super关键字可以用来调用父类的无参构造方法，但是必须放在子类构造方法的第一行(格式：super();)
        //super关键字可以用来调用父类的有参构造方法，但是必须放在子类构造方法的第一行(格式：super(参数);这里的参数是父类构造方法的参数)
        /*
        super调用有参和无参构造函数举例：
        class A{
            public A(){
                System.out.println("A");
            }
            public A(int a){
                System.out.println("A" + a);
            }
        }
        class B extends A{
            public B(){
                super(); //调用父类的无参构造方法
                System.out.println("B");
            }
            public
        }
        B b = new B();
        //输出结果：
        //A
        //B

        class C extends A{
            public C(){
                super(10); //调用父类的有参构造方法
                System.out.println("C");
            }
        }
        C b = new C();
        //输出结果：
        //A10
        //C
         */

        //instanceof关键字:用来判断一个对象是否是一个类的实例,  格式：对象 instanceof 类名,  如果是返回true,否则返回false

        //final关键字
        //final关键字可以修饰类、方法、变量
        /*
        1. 修饰类：被final修饰的类不能被继承
        2. 修饰方法：被final修饰的方法不能被重写
        3. 修饰变量：被final修饰的变量是一个常量，只能赋值一次，一般和static一起使用，表示一个常量
         */


        //类的上转型对象
        //上转型对象：父类的引用指向子类的对象（格式：父类名 对象名 = new 子类名();）
        /*
        如：
        class A{}
        class B extends A{}
        A a = new B();
        在这里a是b的上转型对象
         */
        //上转型对象的使用
        /*
        1.上转型对象只能调用父类的属性和方法，不能调用子类的新增的属性和方法
        2.上转型对象可以访问子类继承或隐藏的成员变量和方法
        3.上转型对象可以调用子类重写的方法，调用的是子类的方法
         */
        //上转型对象的使用场景
        /*
        1. 方法的形参是父类类型，实参是子类对象
        2. 方法的返回值是父类类型，返回值是子类对象
         */


        //多态
        //多态：父类的引用指向子类的对象，通过父类的引用调用子类的方法，这种机制就是多态
        //多态的前提：1.要有继承关系 2.要有方法重写 3.要有父类的引用指向子类的对象
        //多态的注意事项：1.成员变量没有多态 2.静态方法没有多态 3.私有方法没有多态 4.构造方法没有多态


        //抽象类与抽象方法
        //抽象类举例：动物类是一个抽象类，猫类和狗类是动物类的子类，猫类和狗类都是抽象类，猫类和狗类的子类是具体类，比如波斯猫类、哈士奇类
        //抽象类：包含抽象方法的类就是抽象类，抽象类不能实例化，只能被继承（格式：abstract class 类名{}）
        //抽象方法：没有方法体的方法就是抽象方法，抽象方法只能存在于抽象类中（格式：abstract 返回值类型 方法名(参数列表);）
        //抽象类的使用：1.抽象类不能实例化 2.抽象类的子类必须重写抽象类的抽象方法，否则子类也是抽象类 3.抽象类的子类可以是抽象类 4.final不能和abstract一起使用
        /*
        抽象类的使用举例：动物类是一个抽象类，猫类和狗类是动物类的子类，猫类和狗类都是抽象类，猫类和狗类的子类是具体类，比如波斯猫类、哈士奇类
        abstract class Animal{
            public abstract void eat();
        }
        abstract class Cat extends Animal{
            public abstract void eat();
        }
        class PersianCat extends Cat{
            public void eat(){
                System.out.println("吃猫粮");
            }
        }
        class Dog extends Animal{
            public void eat(){
                System.out.println("吃狗粮");
            }
        }
         */
    }
}